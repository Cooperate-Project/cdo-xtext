/*
 * generated by Xtext
 */
package net.winklerweb.cdoxtext.example.cdoxtext

import net.winklerweb.cdoxtext.example.graphix.Circle
import net.winklerweb.cdoxtext.example.graphix.Color
import net.winklerweb.cdoxtext.example.graphix.GraphixCanvas
import net.winklerweb.cdoxtext.example.graphix.Point
import org.apache.commons.lang.StringUtils
import org.eclipse.emf.cdo.CDOObject
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.compare.Comparison
import org.eclipse.emf.compare.match.eobject.ProximityEObjectMatcher
import org.eclipse.emf.ecore.EObject
import org.eclipse.emf.ecore.EReference

class GraphixDistanceFunction implements ProximityEObjectMatcher.DistanceFunction { 
	
	override distance(Comparison comp, EObject a, EObject b) {
		if (!a.eClass.equals(b.eClass)) {
			return Integer::MAX_VALUE
		}

		val result = compareObjects(a as CDOObject,b as CDOObject)
		return result;
	}
	
	def double internalCompareObjects(CDOObject a, CDOObject b) {
		if(a === null && b === null) {
			return 0.0d
		}
		
		if(a === null || b === null) {
			return 10000.0d
		}
		
		return compareObjects(a,b)
	}
	
	def dispatch double compareObjects(GraphixCanvas a, GraphixCanvas b) {
		return 0.0d
	}

	def dispatch double compareObjects(Color a, Color b) {
		return (StringUtils::getLevenshteinDistance(a.name, b.name) as double)
		  * (100.0 * (Math::abs(a.red - b.red) + Math::abs(a.green - b.green) + Math::abs(a.blue - b.blue)))
	}

	def dispatch double compareObjects(Point a, Point b) {
		return compareContainment(a, b) + Math::abs(a.x - a.y) + Math::abs(b.x - b.y)
	}

	def dispatch double compareObjects(Circle a, Circle b) {
		return Math::abs(a.radius - b.radius) + Math::abs(a.center.x - b.center.x) + Math::abs(a.center.y - b.center.y) 
		+ 0.5 * internalCompareObjects(a.lineColor, b.lineColor) + 0.5 * internalCompareObjects(a.fillColor, b.fillColor)
	}
	
	def compareContainment(EObject a, EObject b) {
		val base1 = if (a.eContainingFeature == b.eContainingFeature) { 0.0d } else { 10.0d } 
		val base2 = if (a.eContainer.eClass == b.eContainer.eClass) { 0.0d } else { 10.0d }
		
		return base1 + base2;
	}
			
	override areIdentic(Comparison comp, EObject a, EObject b) {
		if(a == null && b == null)
			return true
			
		if(a == null || b == null)
			return false
		
		if(a.eClass == null && b.eClass == null) {
			return a == b
		}
		
		if(a.eClass == null || b.eClass == null) {
			return false
		}
		
		if(a.eClass != b.eClass) {
			return false
		} else {
			return a.eClass.EStructuralFeatures.forall[ f |
				if(f.many) {
					val list_a = a.eGet(f) as EList
					val list_b = b.eGet(f) as EList
					if(list_a.size() != list_b.size()) {
						false
					} else {
						var result = true
						for(i : 0 ..< list_a.size()) {
							if(f instanceof EReference) {
								result = result && areIdentic(comp, list_a.get(i) as EObject, list_b.get(i) as EObject)
							} else {
								result = result && list_a.get(i) == list_b.get(i)
							}
						}
						result
					}
				} else {
					if(f instanceof EReference) {
						areIdentic(comp, a.eGet(f) as EObject, b.eGet(f) as EObject)
					} else {
						a.eGet(f) == b.eGet(f)
					}
				}
			]
		}
	}		
}
